<head>
    <style>
        #tron-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        .tron-loader {
            position: relative;
            z-index: 1;
            color: #0ff;
            font-family: 'Tron', sans-serif; /* Make sure to include the Tron-like font or use a similar web-safe font */
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff, 0 0 40px #0ff, 0 0 70px #0ff;
        }

        .loading-text {
            font-size: 2em;
            animation: flicker 1.5s infinite alternate;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="loading-screen" style="display: flex; align-items: center; justify-content: center; height: 100vh; background-color: #000;">
        <canvas id="tron-canvas"></canvas>
        <div class="tron-loader">
          <!-- You can place a static loader graphic here, or build your custom animated elements -->
          <div class="loading-text">
            Loading...
          </div>
        </div>
      </div>

</body>

  <script>
document.addEventListener('DOMContentLoaded', (event) => {
  const canvas = document.getElementById('tron-canvas');
  const ctx = canvas.getContext('2d');
  let lines = [];
  const density = 0.000005;
  const cycleSize = 5; // Configurable size of the cycle
  const trailWidth = 5; // Configurable width of the trail
  const speed = 1; // Configurable speed of the cycles
  let directionChangeDistance = 500; // Configurable distance before direction change
  const trailLength = 200; // Configurable length of the trail

  // Function to resize canvas and reinitialize lines
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initLines();
  }

  function assignCycleColors(numberOfCycles) {
    const colors = [];
    for (let i = 0; i < numberOfCycles; i++) {
      colors.push(i % 2 === 0 ? '#0ff' : '#ffa500');
    }
    return colors;
  }

  class Line {
    constructor(color) {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.color = color;
      this.directionChangeCounter = directionChangeDistance;
      this.history = [];
      this.changeDirection();
    }

    changeDirection() {
      const directions = ['up', 'down', 'left', 'right'];
      this.direction = directions[Math.floor(Math.random() * directions.length)];
    }

    draw() {
      this.directionChangeCounter -= speed;
      if (this.directionChangeCounter <= 0) {
        this.changeDirection();
        this.directionChangeCounter = directionChangeDistance;
      }

      // Update position and check for boundaries
      switch (this.direction) {
        case 'up':
          this.y -= speed;
          break;
        case 'down':
          this.y += speed;
          break;
        case 'left':
          this.x -= speed;
          break;
        case 'right':
          this.x += speed;
          break;
      }

      this.x = Math.max(0, Math.min(this.x, canvas.width));
      this.y = Math.max(0, Math.min(this.y, canvas.height));

      // Add to history
      this.history.push({ x: this.x, y: this.y });
      if (this.history.length > trailLength) {
        this.history.shift();
      }

      // Draw cycle
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x - cycleSize / 2, this.y - cycleSize / 2, cycleSize, cycleSize);

      // Draw trail
      ctx.beginPath();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = trailWidth;

      for (let i = 1; i < this.history.length; i++) {
        ctx.moveTo(this.history[i - 1].x, this.history[i - 1].y);
        ctx.lineTo(this.history[i].x, this.history[i].y);
      }

      ctx.stroke();
    }
  }

  function initLines() {
    lines = [];
    const numberOfLines = Math.floor(canvas.width * canvas.height * density);
    const cycleColors = assignCycleColors(numberOfLines);
    for (let i = 0; i < numberOfLines; i++) {
      lines.push(new Line(cycleColors[i]));
    }
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
    lines.forEach(line => line.draw());
    requestAnimationFrame(animate);
  }

  // Adjust canvas size when the window is resized
  window.addEventListener('resize', resizeCanvas, false);

  resizeCanvas(); // Initialize canvas size and lines
  animate();
});
  </script>